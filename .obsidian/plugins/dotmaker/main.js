/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
__export(exports, {
  default: () => MyPlugin
});
var import_obsidian = __toModule(require("obsidian"));
var { exec } = require("child_process");
var nodeData = {};
var edgeData = {};
var graphDot = {};
var bcNodeList = app.plugins.plugins.breadcrumbs.mainG.toJSON().nodes;
var bcEdgeList = app.plugins.plugins.breadcrumbs.mainG.toJSON().edges;
function debug() {
  console.log("nodeData", nodeData);
  console.log("edgeData", edgeData);
  console.log("graphDot", graphDot);
  console.log("process.cwd()", process.cwd());
}
var workingDirectory = app.vault.adapter.getBasePath() + "\\" + app.vault.configDir + "\\plugins\\dotmaker\\graphs\\";
console.log("Starting directory: " + process.cwd());
try {
  process.chdir(workingDirectory);
  console.log("New directory: " + process.cwd());
} catch (err) {
  console.log("chdir: " + err);
}
var MyPlugin = class extends import_obsidian.Plugin {
  onload() {
    return __async(this, null, function* () {
      console.clear();
      const nodeTypeListDeclaration = {
        masterGraph: {
          style: 'shape=plaintext style="filled, rounded" fontname="SVN-Avo" margin=0.2 fillcolor="#c6cac3"',
          graphHeader: `
overlap=false
style=rounded
// ranksep="0.4";
label="C\xF4ng vi\u1EC7c PMN";
//sep=10
fontsize = 30
labelloc="t";
fontname="Lato";`
        },
        "C\xF4ng vi\u1EC7c th\xE0nh ph\u1EA7n": {
          method: "End of edge type",
          style: "shape=polygon"
        },
        next: {
          method: "End of edge type",
          style: "shape=polygon",
          cluster: true,
          subgraphSetting: ""
        }
      };
      const edgeTypeListDeclaration = {
        masterGraph: {
          style: "penwidth=1"
        },
        "C\xF4ng vi\u1EC7c th\xE0nh ph\u1EA7n": {
          style: "penwidth=1 style=solid"
        },
        next: {
          style: "penwidth=1 style=dashed"
        }
      };
      const nodeTypeList = Object.keys(nodeTypeListDeclaration);
      const edgeTypeList = Object.keys(edgeTypeListDeclaration);
      var IsBreadcrumbsrunning = new Promise((resolve, reject) => {
        if (bcEdgeList.length !== 0) {
          resolve("Breadcrumbs is running properly");
        } else {
          reject("Breadcrumbs has problem");
        }
      });
      IsBreadcrumbsrunning.then((message) => console.log(message)).catch((message) => console.log(message));
      function makeLabel(name) {
        return name.replace(/(?![^\n]{1,32}$)([^\n]{1,32})\s/g, "$1\\n").replace(/[❝❞]/g, '\\"');
      }
      function IndividualNodeType(nodetype, i2) {
        this.settings = nodeTypeListDeclaration[nodetype];
        this.settings.order = i2;
        this.nodes = [];
        this.neighborNode = {
          sourceOf: [],
          targetOf: []
        };
      }
      function IndividualNode(name, nodetype) {
        this.name = name;
        this.label = makeLabel(this.name);
        this.index = this.name.split(" ")[0];
        this.path = this.name + ".md";
        this.folder = this.path.split("/").slice(0, -1).join("/");
        this.tag = "none";
        this.frontmatter = "none";
        this.inMetadata = false;
        this.endOfEdgeType = nodetype;
        this.neighbor = {
          sourceOf: bcEdgeList.filter((edge) => edge.source == this.name).map((edge) => edge.target),
          targetOf: bcEdgeList.filter((edge) => edge.target == this.name).map((edge) => edge.source)
        };
        this.existsInMetadata = function() {
          if (Object.keys(app.metadataCache.fileCache).includes(this.path)) {
            this.inMetadata = true;
            var nodeMetadata = app.metadataCache.getCache(this.path);
            if (nodeMetadata.frontmatter !== void 0) {
              this.frontmatter = nodeMetadata.frontmatter;
            }
            if (nodeMetadata.tags !== void 0) {
              this.tag = nodeMetadata.tags;
            }
          }
        };
      }
      function createNodeTmp(item, nodetype, nodeTypeTmp) {
        const nodeTmp = new IndividualNode(item.target, nodetype);
        nodeTmp.existsInMetadata();
        nodeTypeTmp.nodes.push(nodeTmp);
      }
      let i = 0;
      nodeTypeList.forEach((nodetype) => {
        const method = nodeTypeListDeclaration[nodetype].method;
        const nodeTypeTmp = new IndividualNodeType(nodetype, i);
        bcEdgeList.forEach((item) => {
          if (method == "End of edge type") {
            if (item.attributes.field == nodetype) {
              createNodeTmp(item, nodetype, nodeTypeTmp);
            }
          }
          if (method == "Index") {
            var branchIndex = nodetype.split("_")[nodetype.split("_").length - 1];
            var itemIndex = item.target.split(" ")[0];
            var itemBranchIndex = itemIndex.split("-")[0].split(".")[0];
            if (itemBranchIndex == branchIndex || itemBranchIndex + "+" == branchIndex) {
              createNodeTmp(item, nodetype, nodeTypeTmp);
            }
          }
        });
        nodeData[nodetype] = nodeTypeTmp;
        i++;
      });
      nodeTypeList.forEach((nodetype) => {
        var tmpTarget = [];
        var tmpSource = [];
        nodeData[nodetype].nodes.forEach((node) => {
          tmpTarget = tmpTarget.concat(node.neighbor.targetOf);
          tmpSource = tmpSource.concat(node.neighbor.sourceOf);
        });
        nodeData[nodetype].neighborNode.targetOf = [...new Set(tmpTarget)];
        nodeData[nodetype].neighborNode.sourceOf = [...new Set(tmpSource)];
      });
      function IndividualEdgeType() {
        this.settings = "";
        this.edges = [];
      }
      function IndividualEdge(start, dir, end, id) {
        this.start = start;
        this.end = end;
        this.id = id;
      }
      const edgeTypeNoDeclare = new IndividualEdgeType();
      edgeTypeNoDeclare.type = "This link field in Breadcrumbs plugin isn't declared in Hierarchical Graph plugin";
      let j = 0;
      edgeTypeList.forEach((edgetype) => {
        const edgeTypeTmp = new IndividualEdgeType();
        edgeTypeTmp.settings = edgeTypeListDeclaration[edgetype];
        edgeTypeTmp.settings.order = j;
        bcEdgeList.forEach((edge) => {
          var bcEdgeField = edge.attributes.field;
          const edgeTmp = new IndividualEdge();
          edgeTmp.start = edge.source;
          edgeTmp.end = edge.target;
          edgeTmp.id = edge.key;
          if (bcEdgeField == edgetype) {
            edgeTypeTmp.edges.push(edgeTmp);
          } else if (!edgeTypeList.includes(bcEdgeField)) {
            edgeTypeNoDeclare.edges.push(edgeTmp);
          }
        });
        edgeData[edgetype] = edgeTypeTmp;
        j++;
      });
      edgeData["No Declared"] = edgeTypeNoDeclare;
      function addNodesForEachGraph(graph, nodetype, node) {
        const neighborNode = nodeData[graph].neighborNode;
        if (graph == "masterGraph") {
          graphDot.masterGraph.nodeSection += `"${node.name}" [ label = "${node.label}" ] 
`;
        }
        if (graph !== "masterGraph" && nodetype == graph) {
          graphDot[graph].nodeSection += `"${node.name}" [ label = "${node.label}" ] 
`;
        }
        if (graph !== "masterGraph" && nodetype !== graph && (neighborNode.sourceOf.includes(node.name) || neighborNode.targetOf.includes(node.name))) {
          graphDot[graph].nodeSection += `"${node.name}" [ label = "${node.label}" ] 
`;
        }
      }
      function addPairingEdgesForEachGraph(graph, edgetype, edge, k2, style) {
        if (graph == "masterGraph") {
          graphDot.masterGraph.edgeSection += `
subgraph cluster_${edgetype}_${k2}{
rank=same
edge [ ${style} ]
"${edge.start}" -> "${edge.end}"
}`;
        }
        if (graph != "masterGraph" && edgetype == graph) {
          graphDot[graph].edgeSection += `
		subgraph cluster_${edgetype}_${k2}{
			rank=same
			edge [ ${style} ]
			"${edge.start}" -> "${edge.end}"
}`;
        }
        k2++;
      }
      function addNonPairingEdgesForEachGraph(graph, edgetype, edge) {
        if (graph == "masterGraph") {
          graphDot.masterGraph.edgeSection += `"${edge.start}" -> "${edge.end}"
`;
        }
        function checkNodeRelationToCurrentGraph(edgetype2, edge2, graph2) {
          var a = nodeData[graph2].nodes.filter((node) => node.name == edge2.start || node.name == edge2.end);
          if (a.length != 0) {
            return true;
          }
        }
        if (graph !== "masterGraph" && checkNodeRelationToCurrentGraph(edgetype, edge, graph)) {
          graphDot[graph].edgeSection += `"${edge.start}" -> "${edge.end}"
`;
        }
      }
      for (const graph in nodeTypeListDeclaration) {
        graphDot[graph] = {
          nodeSection: "",
          edgeSection: "",
          final: ""
        };
        graphDot[graph].nodeSection = `//NODES
//====================

`;
        nodeTypeList.forEach((nodetype) => {
          const style = nodeData[nodetype].settings.style;
          const cluster = nodeData[nodetype].settings.cluster;
          const subgraphSetting = nodeData[nodetype].settings.subgraphSetting;
          graphDot[graph].nodeSection += `
node [ ${nodeData.masterGraph.settings.style} ] //Reset style

`;
          graphDot[graph].nodeSection += `//All ${nodetype} nodes
`;
          if (cluster == true) {
            graphDot[graph].nodeSection += `subgraph cluster_${nodetype}{
${subgraphSetting}
`;
          }
          if (style !== void 0) {
            graphDot[graph].nodeSection += `
node [ ${style} ]
`;
          }
          nodeData[nodetype].nodes.forEach((node) => addNodesForEachGraph(graph, nodetype, node));
          if (cluster == true) {
            graphDot[graph].nodeSection += `}
`;
          }
        });
        graphDot[graph].edgeSection = `

//EDGES
//====================
`;
        var k = 0;
        edgeTypeList.forEach((edgetype) => {
          const sameRank = edgeData[edgetype].settings.sameRank;
          const cluster = edgeData[edgetype].settings.cluster;
          const style = edgeData[edgetype].settings.style;
          const pairing = edgeData[edgetype].settings.pairing;
          if (edgeData.masterGraph.settings.style !== void 0) {
            graphDot[graph].edgeSection += `
edge [ ${edgeData.masterGraph.settings.style} ] //Reset style
`;
          }
          graphDot[graph].edgeSection += `
//All ${edgetype} edges
`;
          if (pairing == true) {
            edgeData[edgetype].edges.forEach((edge) => {
              addPairingEdgesForEachGraph(graph, edgetype, edge, k, style);
              k++;
            });
          } else {
            if (cluster == true && sameRank == true) {
              graphDot[graph].edgeSection += `subgraph cluster_${edgetype}{
rank=same
`;
            }
            if (cluster == true && sameRank !== true) {
              graphDot[graph].edgeSection += `subgraph cluster_${edgetype}{
`;
            }
            if (cluster !== true && sameRank == true) {
              graphDot[graph].edgeSection += `subgraph {
rank=same
`;
            }
            if (style !== void 0) {
              graphDot[graph].edgeSection += `
edge [ ${style} ]
`;
            }
            edgeData[edgetype].edges.forEach((edge) => {
              addNonPairingEdgesForEachGraph(graph, edgetype, edge);
            });
            if (cluster == true || sameRank == true) {
              graphDot[graph].edgeSection += `}
`;
            }
          }
        });
        graphDot[graph].edgeSection += `
}`;
        graphDot[graph].final = `digraph "${graph}"{
${nodeData.masterGraph.settings.graphHeader}
`;
        graphDot[graph].final += graphDot[graph].nodeSection + graphDot[graph].edgeSection;
        const commandList = [
          `unflatten -l 3 "${graph}.dot" -o unflatten_"${graph}.dot"`,
          `dot -Tpng unflatten_"${graph}.dot" -o dot_""${graph}.png""`,
          `neato -Tpng "${graph}.dot" -o neato_"${graph}.png"`,
          `sfdp -Tpng "${graph}.dot" -o sfdp_"${graph}.png"`
        ];
        var filePath = app.vault.configDir + "\\plugins\\dotmaker\\graphs\\" + graph + ".dot";
        app.vault.adapter.write(filePath, graphDot[graph].final);
        commandList.forEach((command) => exec(command, (error, stdout, stderr) => {
          console.log("filePath:", filePath);
          console.log("graph:", graph, "command:", command);
          console.log("stdout:", stdout);
          console.log("stderr:", stderr);
          if (error !== null) {
            console.log(`exec error: ${error}`);
          }
        }));
      }
      debug();
      console.log(graphDot.branch_0);
      console.log("done");
    });
  }
  onunload() {
    console.log("unloading plugin");
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vUHJvZ3JhbW1pbmcvT2JzaWRpYW4vZG90bWFrZXIvbWFpbi50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLyogTmFtaW5nIGNvbnZlbnRpb25cclxuYmMgcHJlZml4OiBCcmVhZGNydW1ic1xyXG5ObyBwcmVmaXg6IEhpZXJhcmNoaWNhbCBHcmFwaFxyXG5hbGxsb3dlcmNhc2U6IGl0ZXJhdGlvbiBpdGVtIG9mIGFuIGFycmF5LmZvckVhY2goKVxyXG58ICAgICAgICAgICAgICAgICAgIHwgQnJlYWRjcnVtYnMgICAgICAgIHwgSGllcmFyY2hpY2FsIGdyYXBoIHxcclxufC0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS18XHJcbnwgUmVsYXRpb25zaGlwICAgICAgfCBMaW5rICAgICAgICAgICAgICAgfCBFZGdlICAgICAgICAgICAgICAgfFxyXG58IFJlbGF0aW9uc2hpcCB0eXBlIHwgTGluayBmaWVsZCAgICAgICAgIHwgRWRnZSB0eXBlICAgICAgICAgIHxcclxufCBOb2RlICAgICAgICAgICAgICB8IFNvdXJjZS90YXJnZXQgbm9kZSB8IFN0YXJ0L2VuZCBub2RlICAgICB8XHJcbiovXHJcbmltcG9ydCB7IFBsdWdpbiB9IGZyb20gJ29ic2lkaWFuJztcclxuY29uc3QgeyBleGVjIH0gPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJyk7XHJcblxyXG52YXIgbm9kZURhdGEgPSB7fSBcclxudmFyIGVkZ2VEYXRhID0ge31cclxuY29uc3QgZ3JhcGhEb3QgPSB7fSAgICBcclxuXHJcbmNvbnN0IGJjTm9kZUxpc3QgPSBhcHAucGx1Z2lucy5wbHVnaW5zLmJyZWFkY3J1bWJzLm1haW5HLnRvSlNPTigpLm5vZGVzIC8vVGhlIG9iamVjdCBzdHJ1Y3R1cmUgaW4gdGhlIEJyZWFkY3J1bWJzIG5vZGUgbGlzdCBpc1xyXG5jb25zdCBiY0VkZ2VMaXN0ID0gYXBwLnBsdWdpbnMucGx1Z2lucy5icmVhZGNydW1icy5tYWluRy50b0pTT04oKS5lZGdlcyAvL2RpZmZlcmVudCB0byB0aGUgb2JqZWN0IHN0cnVjdHVyZSBpbiB0aGUgZWRnZSBsaXN0XHJcbmZ1bmN0aW9uIGRlYnVnKCkge1xyXG5cdGNvbnNvbGUubG9nKFwibm9kZURhdGFcIiwgbm9kZURhdGEpXHJcblx0Y29uc29sZS5sb2coXCJlZGdlRGF0YVwiLCBlZGdlRGF0YSlcclxuXHRjb25zb2xlLmxvZyhcImdyYXBoRG90XCIsIGdyYXBoRG90KVxyXG5cdGNvbnNvbGUubG9nKFwicHJvY2Vzcy5jd2QoKVwiLCBwcm9jZXNzLmN3ZCgpKVxyXG59IFxyXG5jb25zdCB3b3JraW5nRGlyZWN0b3J5ID0gYXBwLnZhdWx0LmFkYXB0ZXIuZ2V0QmFzZVBhdGgoKSArIFwiXFxcXFwiICsgYXBwLnZhdWx0LmNvbmZpZ0RpciArIFwiXFxcXHBsdWdpbnNcXFxcZG90bWFrZXJcXFxcZ3JhcGhzXFxcXFwiIFxyXG5jb25zb2xlLmxvZygnU3RhcnRpbmcgZGlyZWN0b3J5OiAnICsgcHJvY2Vzcy5jd2QoKSk7XHJcbnRyeSB7XHJcblx0cHJvY2Vzcy5jaGRpcih3b3JraW5nRGlyZWN0b3J5KTtcclxuXHRjb25zb2xlLmxvZygnTmV3IGRpcmVjdG9yeTogJyArIHByb2Nlc3MuY3dkKCkpO1xyXG59XHJcbmNhdGNoIChlcnIpIHtcclxuXHRjb25zb2xlLmxvZygnY2hkaXI6ICcgKyBlcnIpO1xyXG59XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE15UGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcclxuXHRhc3luYyBvbmxvYWQoKSB7XHJcblx0XHRcclxuY29uc29sZS5jbGVhcigpXHJcbi8qIFBhcnQgMTogSW5pdGlhbCBkYXRhICovXHJcblxyXG5jb25zdCBub2RlVHlwZUxpc3REZWNsYXJhdGlvbiA9IHsgLy9TdHlsZXMgdXNlZCBpbiBmaW5hbCBncmFwaCBmb3IgZWFjaCBub2RlIHR5cGVcclxuXHRtYXN0ZXJHcmFwaDogeyBcclxuXHRcdFx0c3R5bGU6IFwic2hhcGU9cGxhaW50ZXh0IHN0eWxlPVxcXCJmaWxsZWQsIHJvdW5kZWRcXFwiIGZvbnRuYW1lPVxcXCJTVk4tQXZvXFxcIiBtYXJnaW49MC4yIGZpbGxjb2xvcj1cXFwiI2M2Y2FjM1xcXCJcIixcclxuXHRcdFx0Z3JhcGhIZWFkZXI6IFxyXG5cdFx0XHRgXHJcbm92ZXJsYXA9ZmFsc2Vcclxuc3R5bGU9cm91bmRlZFxyXG4vLyByYW5rc2VwPVwiMC40XCI7XHJcbmxhYmVsPVwiQ1x1MDBGNG5nIHZpXHUxRUM3YyBQTU5cIjtcclxuLy9zZXA9MTBcclxuZm9udHNpemUgPSAzMFxyXG5sYWJlbGxvYz1cInRcIjtcclxuZm9udG5hbWU9XCJMYXRvXCI7YCwgXHJcblx0fSxcclxuXHRcIkNcdTAwRjRuZyB2aVx1MUVDN2MgdGhcdTAwRTBuaCBwaFx1MUVBN25cIjoge1xyXG5cdFx0bWV0aG9kOiBcIkVuZCBvZiBlZGdlIHR5cGVcIixcclxuXHRcdHN0eWxlOiBcInNoYXBlPXBvbHlnb25cIlxyXG5cdH0sXHJcblx0bmV4dDoge1xyXG5cdFx0bWV0aG9kOiBcIkVuZCBvZiBlZGdlIHR5cGVcIixcclxuXHRcdHN0eWxlOiBcInNoYXBlPXBvbHlnb25cIixcclxuXHRcdGNsdXN0ZXI6IHRydWUsXHJcblx0XHRzdWJncmFwaFNldHRpbmc6IFwiXCJcclxuXHR9LFxyXG59IFxyXG5jb25zdCBlZGdlVHlwZUxpc3REZWNsYXJhdGlvbiA9IHsgLy9TdHlsZXMgdXNlZCBpbiBmaW5hbCBncmFwaCBmb3IgZWFjaCBlZGdlIHR5cGVcclxuXHRtYXN0ZXJHcmFwaDoge1xyXG5cdFx0c3R5bGU6IFwicGVud2lkdGg9MVwiIFxyXG5cdH0sIFxyXG5cdFwiQ1x1MDBGNG5nIHZpXHUxRUM3YyB0aFx1MDBFMG5oIHBoXHUxRUE3blwiOiB7XHJcblx0XHRzdHlsZTogXCJwZW53aWR0aD0xIHN0eWxlPXNvbGlkXCIgXHJcblx0fSxcclxuXHRuZXh0OiB7XHJcblx0XHRzdHlsZTogXCJwZW53aWR0aD0xIHN0eWxlPWRhc2hlZFwiIFxyXG5cdH0sIFxyXG59XHJcbmNvbnN0IG5vZGVUeXBlTGlzdCA9IE9iamVjdC5rZXlzKG5vZGVUeXBlTGlzdERlY2xhcmF0aW9uKVxyXG5jb25zdCBlZGdlVHlwZUxpc3QgPSBPYmplY3Qua2V5cyhlZGdlVHlwZUxpc3REZWNsYXJhdGlvbilcclxuXHJcbnZhciBJc0JyZWFkY3J1bWJzcnVubmluZyA9IG5ldyBQcm9taXNlKChyZXNvbHZlLHJlamVjdCkgPT4ge1xyXG5cdGlmKGJjRWRnZUxpc3QubGVuZ3RoICE9PSAwKXtcclxuXHRcdHJlc29sdmUoJ0JyZWFkY3J1bWJzIGlzIHJ1bm5pbmcgcHJvcGVybHknKSBcclxuXHR9IGVsc2Uge1xyXG5cdFx0cmVqZWN0KCdCcmVhZGNydW1icyBoYXMgcHJvYmxlbScpIFxyXG5cdH0gXHJcbn0pXHJcbklzQnJlYWRjcnVtYnNydW5uaW5nLnRoZW4obWVzc2FnZSA9PiBjb25zb2xlLmxvZyhtZXNzYWdlKSlcclxuLmNhdGNoKG1lc3NhZ2UgPT4gY29uc29sZS5sb2cobWVzc2FnZSkpXHJcblxyXG5cclxuLyogUGFydCAyOiBSZXN0cnVjdHVyaW5nIHRoZSBCcmVhZGNydW1icyBkYXRhYmFzZTsgY3JlYXRpbmcgYmV0dGVyIHN1aXRlZCBkYXRhYmFzZSBmb3IgdGhlIGdvYWwgKi9cclxuLyogUGFydCAyLjE6IEJ1bGRpbmcgbm9kZSBvYmplY3QgKi9cclxuZnVuY3Rpb24gbWFrZUxhYmVsKG5hbWUpeyBcclxuXHRyZXR1cm4gbmFtZS5yZXBsYWNlKC8oPyFbXlxcbl17MSwzMn0kKShbXlxcbl17MSwzMn0pXFxzL2csICckMVxcXFxuJykucmVwbGFjZSgvW1x1Mjc1RFx1Mjc1RV0vZywnXFxcXFwiJylcclxufSBcclxuZnVuY3Rpb24gSW5kaXZpZHVhbE5vZGVUeXBlKG5vZGV0eXBlOiBzdHJpbmcsIGk6IG51bWJlcil7XHJcblx0dGhpcy5zZXR0aW5ncyA9IG5vZGVUeXBlTGlzdERlY2xhcmF0aW9uW25vZGV0eXBlXVxyXG5cdHRoaXMuc2V0dGluZ3Mub3JkZXIgPSBpXHJcblx0dGhpcy5ub2RlcyA9IFtdXHJcblx0dGhpcy5uZWlnaGJvck5vZGUgPSB7XHJcblx0XHRzb3VyY2VPZjogW10gLFxyXG5cdFx0dGFyZ2V0T2Y6IFtdfSBcclxufVxyXG5mdW5jdGlvbiBJbmRpdmlkdWFsTm9kZSAoIG5hbWU6IHN0cmluZywgbm9kZXR5cGU6IHN0cmluZykge1xyXG5cdHRoaXMubmFtZSA9IG5hbWVcclxuXHR0aGlzLmxhYmVsID0gbWFrZUxhYmVsKHRoaXMubmFtZSlcclxuXHR0aGlzLmluZGV4ID0gdGhpcy5uYW1lLnNwbGl0KFwiIFwiKVswXVxyXG5cdHRoaXMucGF0aCA9IHRoaXMubmFtZStcIi5tZFwiXHJcblx0dGhpcy5mb2xkZXIgPSB0aGlzLnBhdGguc3BsaXQoXCIvXCIpLnNsaWNlKDAsIC0xKS5qb2luKCcvJylcclxuXHR0aGlzLnRhZyA9IFwibm9uZVwiXHJcblx0dGhpcy5mcm9udG1hdHRlciA9IFwibm9uZVwiXHJcblx0dGhpcy5pbk1ldGFkYXRhID0gZmFsc2VcclxuXHR0aGlzLmVuZE9mRWRnZVR5cGUgPSBub2RldHlwZVxyXG5cdHRoaXMubmVpZ2hib3IgPSB7IFxyXG5cdFx0c291cmNlT2Y6IGJjRWRnZUxpc3QuZmlsdGVyKGVkZ2UgPT4gZWRnZS5zb3VyY2U9PXRoaXMubmFtZSkubWFwKGVkZ2UgPT4gZWRnZS50YXJnZXQpLFxyXG5cdFx0dGFyZ2V0T2Y6IGJjRWRnZUxpc3QuZmlsdGVyKGVkZ2UgPT4gZWRnZS50YXJnZXQ9PXRoaXMubmFtZSkubWFwKGVkZ2UgPT4gZWRnZS5zb3VyY2UpfSBcclxuXHRcclxuXHR0aGlzLmV4aXN0c0luTWV0YWRhdGEgPSBmdW5jdGlvbigpIHtcclxuXHRcdGlmIChPYmplY3Qua2V5cyhhcHAubWV0YWRhdGFDYWNoZS5maWxlQ2FjaGUpLmluY2x1ZGVzKHRoaXMucGF0aCkpeyBcclxuXHRcdFx0dGhpcy5pbk1ldGFkYXRhID0gdHJ1ZVxyXG5cdFx0XHR2YXIgbm9kZU1ldGFkYXRhID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0Q2FjaGUodGhpcy5wYXRoKVxyXG5cdFx0XHRpZiAobm9kZU1ldGFkYXRhLmZyb250bWF0dGVyICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHR0aGlzLmZyb250bWF0dGVyID0gbm9kZU1ldGFkYXRhLmZyb250bWF0dGVyXHJcblx0XHRcdH0gXHJcblx0XHRcdGlmIChub2RlTWV0YWRhdGEudGFncyAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0dGhpcy50YWcgPSBub2RlTWV0YWRhdGEudGFnc1xyXG5cdFx0XHR9IFxyXG5cdFx0fVxyXG5cdH0gXHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlTm9kZVRtcChpdGVtLCBub2RldHlwZSwgbm9kZVR5cGVUbXApe1xyXG5cdGNvbnN0IG5vZGVUbXAgPSBuZXcgSW5kaXZpZHVhbE5vZGUoaXRlbS50YXJnZXQsIG5vZGV0eXBlKSBcclxuXHRcdFx0XHJcblx0bm9kZVRtcC5leGlzdHNJbk1ldGFkYXRhKCkgXHJcblx0bm9kZVR5cGVUbXAubm9kZXMucHVzaChub2RlVG1wKSBcdFxyXG59IFxyXG5sZXQgaT0wXHJcbm5vZGVUeXBlTGlzdC5mb3JFYWNoKG5vZGV0eXBlID0+IHtcclxuXHRjb25zdCBtZXRob2QgPSBub2RlVHlwZUxpc3REZWNsYXJhdGlvbltub2RldHlwZV0ubWV0aG9kXHJcblx0Y29uc3Qgbm9kZVR5cGVUbXAgPSBuZXcgSW5kaXZpZHVhbE5vZGVUeXBlKG5vZGV0eXBlLCBpKSBcclxuXHJcblx0YmNFZGdlTGlzdC5mb3JFYWNoKGl0ZW0gPT4ge1xyXG5cdFx0aWYgKG1ldGhvZD09XCJFbmQgb2YgZWRnZSB0eXBlXCIpIHtcclxuXHRcdFx0aWYoaXRlbS5hdHRyaWJ1dGVzLmZpZWxkID09IG5vZGV0eXBlKSB7XHJcblx0XHRcdFx0Y3JlYXRlTm9kZVRtcChpdGVtLCBub2RldHlwZSwgbm9kZVR5cGVUbXApIFxyXG5cdFx0XHR9XHJcblx0XHR9IFxyXG5cdFx0aWYgKG1ldGhvZD09XCJJbmRleFwiKSB7XHJcblx0XHRcdHZhciBicmFuY2hJbmRleCA9IG5vZGV0eXBlLnNwbGl0KFwiX1wiKVtub2RldHlwZS5zcGxpdChcIl9cIikubGVuZ3RoIC0gMV0gXHJcblx0XHRcdHZhciBpdGVtSW5kZXggPSBpdGVtLnRhcmdldC5zcGxpdChcIiBcIilbMF1cclxuXHRcdFx0dmFyIGl0ZW1CcmFuY2hJbmRleCA9IGl0ZW1JbmRleC5zcGxpdChcIi1cIilbMF0uc3BsaXQoXCIuXCIpWzBdXHJcblx0XHRcdFxyXG5cdFx0XHRpZiAoaXRlbUJyYW5jaEluZGV4ID09IGJyYW5jaEluZGV4IHx8IGl0ZW1CcmFuY2hJbmRleCtcIitcIiA9PSBicmFuY2hJbmRleCkgeyBcclxuXHRcdFx0XHRjcmVhdGVOb2RlVG1wKGl0ZW0sIG5vZGV0eXBlLCBub2RlVHlwZVRtcClcclxuXHRcdFx0fSBcclxuXHRcdH1cclxuXHR9KVxyXG5cdG5vZGVEYXRhW25vZGV0eXBlXSA9IG5vZGVUeXBlVG1wXHJcblx0aSsrXHJcbn0pXHJcbm5vZGVUeXBlTGlzdC5mb3JFYWNoKG5vZGV0eXBlID0+IHtcclxuXHR2YXIgdG1wVGFyZ2V0ID0gW10gXHJcblx0dmFyIHRtcFNvdXJjZSA9IFtdIFxyXG5cdG5vZGVEYXRhW25vZGV0eXBlXS5ub2Rlcy5mb3JFYWNoKG5vZGU9PiB7XHJcblx0XHR0bXBUYXJnZXQgPSB0bXBUYXJnZXQuY29uY2F0KG5vZGUubmVpZ2hib3IudGFyZ2V0T2YpXHJcblx0XHR0bXBTb3VyY2UgPSB0bXBTb3VyY2UuY29uY2F0KG5vZGUubmVpZ2hib3Iuc291cmNlT2YpXHJcblx0fSlcclxuXHRub2RlRGF0YVtub2RldHlwZV0ubmVpZ2hib3JOb2RlLnRhcmdldE9mID0gWy4uLm5ldyBTZXQodG1wVGFyZ2V0KV1cclxuXHRub2RlRGF0YVtub2RldHlwZV0ubmVpZ2hib3JOb2RlLnNvdXJjZU9mID0gWy4uLm5ldyBTZXQodG1wU291cmNlKV1cclxufSlcclxuIFxyXG4vKiBQYXJ0IDIuMjogQnVsZGluZyBlZGdlIG9iamVjdCAqL1xyXG5mdW5jdGlvbiBJbmRpdmlkdWFsRWRnZVR5cGUoKXtcclxuXHR0aGlzLnNldHRpbmdzID0gXCJcIiBcclxuXHR0aGlzLmVkZ2VzID0gW11cclxufVxyXG5mdW5jdGlvbiBJbmRpdmlkdWFsRWRnZSAoc3RhcnQ6IHN0cmluZywgZGlyOiBzdHJpbmcsIGVuZDogc3RyaW5nLCBpZDogc3RyaW5nKSB7XHJcblx0dGhpcy5zdGFydCA9IHN0YXJ0XHJcblx0dGhpcy5lbmQgPSBlbmRcclxuXHR0aGlzLmlkID0gaWRcclxufVxyXG5jb25zdCBlZGdlVHlwZU5vRGVjbGFyZSA9IG5ldyBJbmRpdmlkdWFsRWRnZVR5cGUoKSBcclxuZWRnZVR5cGVOb0RlY2xhcmUudHlwZSA9IFwiVGhpcyBsaW5rIGZpZWxkIGluIEJyZWFkY3J1bWJzIHBsdWdpbiBpc24ndCBkZWNsYXJlZCBpbiBIaWVyYXJjaGljYWwgR3JhcGggcGx1Z2luXCIgXHJcbmxldCBqPTBcclxuXHJcbmVkZ2VUeXBlTGlzdC5mb3JFYWNoKGVkZ2V0eXBlID0+IHtcclxuXHRjb25zdCBlZGdlVHlwZVRtcCA9IG5ldyBJbmRpdmlkdWFsRWRnZVR5cGUoKSBcclxuXHRlZGdlVHlwZVRtcC5zZXR0aW5ncyA9IGVkZ2VUeXBlTGlzdERlY2xhcmF0aW9uW2VkZ2V0eXBlXVxyXG5cdGVkZ2VUeXBlVG1wLnNldHRpbmdzLm9yZGVyID0galxyXG5cclxuXHRiY0VkZ2VMaXN0LmZvckVhY2goZWRnZSA9PiB7XHJcblx0XHR2YXIgYmNFZGdlRmllbGQgPSBlZGdlLmF0dHJpYnV0ZXMuZmllbGRcclxuXHRcdGNvbnN0IGVkZ2VUbXAgPSBuZXcgSW5kaXZpZHVhbEVkZ2UoKSBcclxuXHRcdGVkZ2VUbXAuc3RhcnQgPSBlZGdlLnNvdXJjZVxyXG5cdFx0ZWRnZVRtcC5lbmQgPSBlZGdlLnRhcmdldFxyXG5cdFx0ZWRnZVRtcC5pZCA9IGVkZ2Uua2V5XHJcblx0XHRpZiAoYmNFZGdlRmllbGQgPT0gZWRnZXR5cGUpIHsgXHJcblx0XHRcdGVkZ2VUeXBlVG1wLmVkZ2VzLnB1c2goZWRnZVRtcCkgXHJcblx0XHR9IFxyXG5cdFx0ZWxzZSBpZiAoIWVkZ2VUeXBlTGlzdC5pbmNsdWRlcyhiY0VkZ2VGaWVsZCkpIHsgXHJcblx0XHRcdGVkZ2VUeXBlTm9EZWNsYXJlLmVkZ2VzLnB1c2goZWRnZVRtcClcclxuXHRcdH1cclxuXHR9KTsgLy9SdW4gdGhyb3VnaCBhbGwgZWRnZXMgaW4gQkMgZWRnZSBsaXN0IChiY0VkZ2VMaXN0KSBcclxuXHRlZGdlRGF0YVtlZGdldHlwZV0gPSBlZGdlVHlwZVRtcFxyXG5cdGorK1xyXG59KSAvL1J1biB0aHJvdWdoIGFsbCBlZGdlIHR5cGVzIGluIEhHIGVkZ2UgdHlwZSBkZWNsYXJhdGlvbiAoZWRnZVR5cGVMaXN0KVxyXG5lZGdlRGF0YVtcIk5vIERlY2xhcmVkXCJdID0gZWRnZVR5cGVOb0RlY2xhcmVcclxuXHJcbi8qIFBhcnQgMzogTWFraW5nIGRvdCBmaWxlXHJcbj09PT09PT09PT09PT09PT09PT09ICovXHJcblxyXG5cclxuZnVuY3Rpb24gYWRkTm9kZXNGb3JFYWNoR3JhcGgoZ3JhcGgsbm9kZXR5cGUsbm9kZSk6IHZvaWQge1xyXG5cdGNvbnN0IG5laWdoYm9yTm9kZSA9IG5vZGVEYXRhW2dyYXBoXS5uZWlnaGJvck5vZGVcclxuXHRcclxuXHRpZiAoZ3JhcGggPT0gXCJtYXN0ZXJHcmFwaFwiKSB7XHJcblx0XHRncmFwaERvdC5tYXN0ZXJHcmFwaC5ub2RlU2VjdGlvbiArPSBgXCIke25vZGUubmFtZX1cIiBbIGxhYmVsID0gXCIke25vZGUubGFiZWx9XCIgXSBcXG5gXHJcblx0fSBcclxuXHRpZiAoZ3JhcGggIT09IFwibWFzdGVyR3JhcGhcIiAmJiBub2RldHlwZSA9PSBncmFwaCkge1xyXG5cdFx0Z3JhcGhEb3RbZ3JhcGhdLm5vZGVTZWN0aW9uICs9IGBcIiR7bm9kZS5uYW1lfVwiIFsgbGFiZWwgPSBcIiR7bm9kZS5sYWJlbH1cIiBdIFxcbmBcclxuXHR9IFxyXG5cdGlmIChncmFwaCAhPT0gXCJtYXN0ZXJHcmFwaFwiICYmIG5vZGV0eXBlICE9PSBncmFwaCAmJiAobmVpZ2hib3JOb2RlLnNvdXJjZU9mLmluY2x1ZGVzKG5vZGUubmFtZSkgfHwgbmVpZ2hib3JOb2RlLnRhcmdldE9mLmluY2x1ZGVzKG5vZGUubmFtZSkpKSB7XHJcblx0XHRncmFwaERvdFtncmFwaF0ubm9kZVNlY3Rpb24gKz0gYFwiJHtub2RlLm5hbWV9XCIgWyBsYWJlbCA9IFwiJHtub2RlLmxhYmVsfVwiIF0gXFxuYFxyXG5cdH0gXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFBhaXJpbmdFZGdlc0ZvckVhY2hHcmFwaChncmFwaCxlZGdldHlwZSxlZGdlLGssc3R5bGUpIHtcclxuXHRpZiAoZ3JhcGggPT0gXCJtYXN0ZXJHcmFwaFwiKSB7XHJcblx0XHRncmFwaERvdC5tYXN0ZXJHcmFwaC5lZGdlU2VjdGlvbiArPSBgXHJcbnN1YmdyYXBoIGNsdXN0ZXJfJHtlZGdldHlwZX1fJHtrfXtcclxucmFuaz1zYW1lXHJcbmVkZ2UgWyAke3N0eWxlfSBdXHJcblwiJHtlZGdlLnN0YXJ0fVwiIC0+IFwiJHtlZGdlLmVuZH1cIlxcbn1gXHJcblx0fSBcclxuXHRpZiAoZ3JhcGggIT0gXCJtYXN0ZXJHcmFwaFwiICYmIGVkZ2V0eXBlID09IGdyYXBoKSB7XHJcblx0XHRncmFwaERvdFtncmFwaF0uZWRnZVNlY3Rpb24gKz0gYFxyXG5cdFx0c3ViZ3JhcGggY2x1c3Rlcl8ke2VkZ2V0eXBlfV8ke2t9e1xyXG5cdFx0XHRyYW5rPXNhbWVcclxuXHRcdFx0ZWRnZSBbICR7c3R5bGV9IF1cclxuXHRcdFx0XCIke2VkZ2Uuc3RhcnR9XCIgLT4gXCIke2VkZ2UuZW5kfVwiXFxufWBcclxuXHRcdH1cclxuXHRcdGsrK1xyXG5cdH1cclxuZnVuY3Rpb24gYWRkTm9uUGFpcmluZ0VkZ2VzRm9yRWFjaEdyYXBoKGdyYXBoLGVkZ2V0eXBlLGVkZ2UpIHtcclxuXHRpZiAoZ3JhcGggPT0gXCJtYXN0ZXJHcmFwaFwiKSB7XHJcblx0XHRncmFwaERvdC5tYXN0ZXJHcmFwaC5lZGdlU2VjdGlvbiArPSBgXCIke2VkZ2Uuc3RhcnR9XCIgLT4gXCIke2VkZ2UuZW5kfVwiXFxuYFxyXG5cdH1cclxuXHRmdW5jdGlvbiBjaGVja05vZGVSZWxhdGlvblRvQ3VycmVudEdyYXBoKGVkZ2V0eXBlLCBlZGdlLCBncmFwaCkge1xyXG5cdFx0dmFyIGEgPSBub2RlRGF0YVtncmFwaF0ubm9kZXMuZmlsdGVyKG5vZGUgPT4gbm9kZS5uYW1lPT1lZGdlLnN0YXJ0IHx8IG5vZGUubmFtZT09ZWRnZS5lbmQpXHJcblx0XHRpZiAoYS5sZW5ndGggIT0wICkge1xyXG5cdFx0XHQvLyBjb25zb2xlLmxvZyhncmFwaCxlZGdldHlwZSwgZWRnZSwgYSlcclxuXHRcdFx0cmV0dXJuIHRydWVcclxuXHRcdH0gXHJcblx0fVxyXG5cdFxyXG5cdGlmIChncmFwaCAhPT0gXCJtYXN0ZXJHcmFwaFwiICYmIGNoZWNrTm9kZVJlbGF0aW9uVG9DdXJyZW50R3JhcGgoZWRnZXR5cGUsIGVkZ2UsIGdyYXBoKSkge1xyXG5cdFx0Z3JhcGhEb3RbZ3JhcGhdLmVkZ2VTZWN0aW9uICs9IGBcIiR7ZWRnZS5zdGFydH1cIiAtPiBcIiR7ZWRnZS5lbmR9XCJcXG5gXHJcblx0fVxyXG59XHJcblxyXG5mb3IgKGNvbnN0IGdyYXBoIGluIG5vZGVUeXBlTGlzdERlY2xhcmF0aW9uKSB7XHJcblx0Z3JhcGhEb3RbZ3JhcGhdID0ge1xyXG5cdFx0bm9kZVNlY3Rpb246IFwiXCIsXHJcblx0XHRlZGdlU2VjdGlvbjogXCJcIixcclxuXHRcdGZpbmFsOiBcIlwiIFxyXG5cdH1cclxuXHJcblx0LyogMy4xOiBQcmludCBhbGwgbm9kZXMgYnkgdHlwZSAqL1xyXG5cdGdyYXBoRG90W2dyYXBoXS5ub2RlU2VjdGlvbiA9IGAvL05PREVTXFxuLy89PT09PT09PT09PT09PT09PT09PVxcblxcbmAgXHJcblx0bm9kZVR5cGVMaXN0LmZvckVhY2gobm9kZXR5cGUgPT4ge1xyXG5cdFx0Y29uc3Qgc3R5bGUgPSBub2RlRGF0YVtub2RldHlwZV0uc2V0dGluZ3Muc3R5bGVcclxuXHRcdGNvbnN0IGNsdXN0ZXIgPSBub2RlRGF0YVtub2RldHlwZV0uc2V0dGluZ3MuY2x1c3RlclxyXG5cdFx0Y29uc3Qgc3ViZ3JhcGhTZXR0aW5nID0gbm9kZURhdGFbbm9kZXR5cGVdLnNldHRpbmdzLnN1YmdyYXBoU2V0dGluZ1xyXG5cdFx0XHJcblx0XHRncmFwaERvdFtncmFwaF0ubm9kZVNlY3Rpb24gKz1cdCBgXFxubm9kZSBbICR7bm9kZURhdGEubWFzdGVyR3JhcGguc2V0dGluZ3Muc3R5bGV9IF0gLy9SZXNldCBzdHlsZVxcblxcbmAgXHJcblx0XHRncmFwaERvdFtncmFwaF0ubm9kZVNlY3Rpb24gKz0gYC8vQWxsICR7bm9kZXR5cGV9IG5vZGVzXFxuYCA7XHJcblx0XHRpZihjbHVzdGVyID09IHRydWUpIHtcclxuXHRcdFx0Z3JhcGhEb3RbZ3JhcGhdLm5vZGVTZWN0aW9uICs9IGBzdWJncmFwaCBjbHVzdGVyXyR7bm9kZXR5cGV9e1xcbiR7c3ViZ3JhcGhTZXR0aW5nfVxcbmBcclxuXHRcdH0gXHJcblx0XHRpZiAoc3R5bGUgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRncmFwaERvdFtncmFwaF0ubm9kZVNlY3Rpb24gKz0gYFxcbm5vZGUgWyAke3N0eWxlfSBdXFxuYFxyXG5cdFx0fSBcclxuXHRcdFxyXG5cdFx0bm9kZURhdGFbbm9kZXR5cGVdLm5vZGVzLmZvckVhY2gobm9kZSA9PiBhZGROb2Rlc0ZvckVhY2hHcmFwaChncmFwaCxub2RldHlwZSxub2RlKSlcclxuXHRcdFxyXG5cdFx0aWYoY2x1c3RlciA9PSB0cnVlKSB7XHJcblx0XHRcdGdyYXBoRG90W2dyYXBoXS5ub2RlU2VjdGlvbiArPSBgfVxcbmBcclxuXHRcdH0gXHJcblx0fSlcclxuXHRcclxuXHRcclxuXHQvKiAzLjI6IFByaW50IGFsbCBlZGdlcyBieSB0eXBlICovXHJcblx0Z3JhcGhEb3RbZ3JhcGhdLmVkZ2VTZWN0aW9uID0gYFxcblxcbi8vRURHRVNcXG4vLz09PT09PT09PT09PT09PT09PT09XFxuYCA7XHJcblx0dmFyIGs9MFxyXG5cdFxyXG5cdGVkZ2VUeXBlTGlzdC5mb3JFYWNoKGVkZ2V0eXBlID0+IHtcclxuXHRcdGNvbnN0IHNhbWVSYW5rID0gZWRnZURhdGFbZWRnZXR5cGVdLnNldHRpbmdzLnNhbWVSYW5rXHJcblx0XHRjb25zdCBjbHVzdGVyID0gZWRnZURhdGFbZWRnZXR5cGVdLnNldHRpbmdzLmNsdXN0ZXJcclxuXHRcdGNvbnN0IHN0eWxlID0gZWRnZURhdGFbZWRnZXR5cGVdLnNldHRpbmdzLnN0eWxlXHJcblx0XHRjb25zdCBwYWlyaW5nID0gZWRnZURhdGFbZWRnZXR5cGVdLnNldHRpbmdzLnBhaXJpbmdcclxuXHRcdFxyXG5cdFx0aWYgKGVkZ2VEYXRhLm1hc3RlckdyYXBoLnNldHRpbmdzLnN0eWxlICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0Z3JhcGhEb3RbZ3JhcGhdLmVkZ2VTZWN0aW9uICs9IGBcXG5lZGdlIFsgJHtlZGdlRGF0YS5tYXN0ZXJHcmFwaC5zZXR0aW5ncy5zdHlsZX0gXSAvL1Jlc2V0IHN0eWxlXFxuYFxyXG5cdFx0fSBcclxuXHRcdGdyYXBoRG90W2dyYXBoXS5lZGdlU2VjdGlvbiArPSBgXFxuLy9BbGwgJHtlZGdldHlwZX0gZWRnZXNcXG5gXHJcblx0XHRcclxuXHRcdGlmIChwYWlyaW5nID09IHRydWUpIHtcclxuXHRcdFx0ZWRnZURhdGFbZWRnZXR5cGVdLmVkZ2VzLmZvckVhY2ggKGVkZ2UgPT4geyBcclxuXHRcdFx0XHRhZGRQYWlyaW5nRWRnZXNGb3JFYWNoR3JhcGgoZ3JhcGgsZWRnZXR5cGUsZWRnZSxrLHN0eWxlKSBcclxuXHRcdFx0XHRrKytcclxuXHRcdFx0fSk7XHJcblx0XHR9IGVsc2UgeyBcclxuXHRcdFx0aWYgKGNsdXN0ZXIgPT0gdHJ1ZSAmJiBzYW1lUmFuayA9PSB0cnVlKSB7XHJcblx0XHRcdFx0Z3JhcGhEb3RbZ3JhcGhdLmVkZ2VTZWN0aW9uICs9IGBzdWJncmFwaCBjbHVzdGVyXyR7ZWRnZXR5cGV9e1xcbnJhbms9c2FtZVxcbmBcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoY2x1c3RlciA9PSB0cnVlICYmIHNhbWVSYW5rICE9PSB0cnVlKSB7XHJcblx0XHRcdFx0Z3JhcGhEb3RbZ3JhcGhdLmVkZ2VTZWN0aW9uICs9IGBzdWJncmFwaCBjbHVzdGVyXyR7ZWRnZXR5cGV9e1xcbmBcclxuXHRcdFx0fSBcclxuXHRcdFx0aWYgKGNsdXN0ZXIgIT09IHRydWUgJiYgc2FtZVJhbmsgPT0gdHJ1ZSkge1xyXG5cdFx0XHRcdGdyYXBoRG90W2dyYXBoXS5lZGdlU2VjdGlvbiArPSBgc3ViZ3JhcGgge1xcbnJhbms9c2FtZVxcbmBcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoc3R5bGUgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdGdyYXBoRG90W2dyYXBoXS5lZGdlU2VjdGlvbiArPSBgXFxuZWRnZSBbICR7c3R5bGV9IF1cXG5gXHJcblx0XHRcdH0gXHJcblx0XHRcdGVkZ2VEYXRhW2VkZ2V0eXBlXS5lZGdlcy5mb3JFYWNoIChlZGdlID0+IHsgXHJcblx0XHRcdFx0YWRkTm9uUGFpcmluZ0VkZ2VzRm9yRWFjaEdyYXBoKGdyYXBoLGVkZ2V0eXBlLGVkZ2UpXHRcclxuXHRcdFx0fSlcclxuXHRcdFx0XHJcblx0XHRcdGlmIChjbHVzdGVyID09IHRydWUgfHwgc2FtZVJhbmsgPT0gdHJ1ZSkge1xyXG5cdFx0XHRcdGdyYXBoRG90W2dyYXBoXS5lZGdlU2VjdGlvbiArPSBgfVxcbmBcclxuXHRcdFx0fSBcclxuXHRcdH0gXHJcblx0fSlcclxuXHRncmFwaERvdFtncmFwaF0uZWRnZVNlY3Rpb24gKz0gYFxcbn1gXHJcblxyXG5cdC8qIDMuMzogQ3JlYXRpbmcgZmluYWwgb3V0cHV0ICovXHJcblx0Z3JhcGhEb3RbZ3JhcGhdLmZpbmFsID0gYGRpZ3JhcGggXFxcIiR7Z3JhcGh9XFxcIntcXG4ke25vZGVEYXRhLm1hc3RlckdyYXBoLnNldHRpbmdzLmdyYXBoSGVhZGVyfVxcbmAgO1xyXG5cdGdyYXBoRG90W2dyYXBoXS5maW5hbCArPSBncmFwaERvdFtncmFwaF0ubm9kZVNlY3Rpb24gKyBncmFwaERvdFtncmFwaF0uZWRnZVNlY3Rpb247XHJcblxyXG5cdC8vIGNvbnNvbGUubG9nKGdyYXBoRG90W2dyYXBoXS5ub2RlU2VjdGlvbilcclxuXHQvLyBjb25zb2xlLmxvZyhncmFwaERvdFtncmFwaF0uZWRnZVNlY3Rpb24pXHJcblx0Ly8gY29uc29sZS5sb2coZ3JhcGhEb3RbZ3JhcGhdLmZpbmFsKVxyXG5cdFxyXG4vKiBQYXJ0IDQ6IEV4cG9ydCB0byBmaWxlIFxyXG49PT09PT09PT09PT09PT09PT09PSovXHRcclxuXHJcblx0Y29uc3QgY29tbWFuZExpc3QgPSBbXHJcblx0XHRgdW5mbGF0dGVuIC1sIDMgXFxcIiR7Z3JhcGh9LmRvdFxcXCIgLW8gdW5mbGF0dGVuX1xcXCIke2dyYXBofS5kb3RcXFwiYCxcclxuXHRcdGBkb3QgLVRwbmcgdW5mbGF0dGVuX1xcXCIke2dyYXBofS5kb3RcXFwiIC1vIGRvdF9cXFwiXFxcIiR7Z3JhcGh9LnBuZ1xcXCJcXFwiYCxcclxuXHRcdGBuZWF0byAtVHBuZyBcXFwiJHtncmFwaH0uZG90XFxcIiAtbyBuZWF0b19cXFwiJHtncmFwaH0ucG5nXFxcImAsXHJcblx0XHRgc2ZkcCAtVHBuZyBcXFwiJHtncmFwaH0uZG90XFxcIiAtbyBzZmRwX1xcXCIke2dyYXBofS5wbmdcXFwiYCxcclxuXHRcdC8vIGB0d29waSAtVHBuZyBcXFwiJHtncmFwaH0uZG90XFxcIiAtbyB0d29waV9cXFwiJHtncmFwaH0ucG5nXFxcImAsXHJcblx0XHQvLyBgY2lyY28gLVRwbmcgXFxcIiR7Z3JhcGh9LmRvdFxcXCIgLW8gY2lyY29fXFxcIiR7Z3JhcGh9LnBuZ1xcXCJgLFxyXG5cdF0gXHRcclxuXHJcblx0dmFyIGZpbGVQYXRoID0gYXBwLnZhdWx0LmNvbmZpZ0RpciArIFwiXFxcXHBsdWdpbnNcXFxcZG90bWFrZXJcXFxcZ3JhcGhzXFxcXFwiICArIGdyYXBoICsgXCIuZG90XCI7XHJcblx0YXBwLnZhdWx0LmFkYXB0ZXIud3JpdGUoZmlsZVBhdGgsZ3JhcGhEb3RbZ3JhcGhdLmZpbmFsKVxyXG5cdC8vIGNvbnNvbGUubG9nKGdyYXBoRG90W2dyYXBoXSApXHJcblx0Y29tbWFuZExpc3QuZm9yRWFjaChjb21tYW5kID0+IGV4ZWMoY29tbWFuZCwgKGVycm9yLCBzdGRvdXQsIHN0ZGVycikgPT4ge1xyXG5cdFx0Y29uc29sZS5sb2coXCJmaWxlUGF0aDpcIiwgZmlsZVBhdGgpXHJcblx0XHRjb25zb2xlLmxvZyhcImdyYXBoOlwiLCBncmFwaCwgXCJjb21tYW5kOlwiLCBjb21tYW5kKVxyXG5cdFx0Y29uc29sZS5sb2coXCJzdGRvdXQ6XCIsIHN0ZG91dCk7XHJcblx0XHRjb25zb2xlLmxvZyhcInN0ZGVycjpcIiwgc3RkZXJyKTtcclxuXHRcdGlmIChlcnJvciAhPT0gbnVsbCkge1xyXG5cdFx0XHRjb25zb2xlLmxvZyhgZXhlYyBlcnJvcjogJHtlcnJvcn1gKTtcclxuXHRcdH1cclxuXHR9KSlcclxufSBcclxuZGVidWcoKVxyXG5jb25zb2xlLmxvZyhncmFwaERvdC5icmFuY2hfMClcclxuY29uc29sZS5sb2coJ2RvbmUnKVxyXG4gXHJcbn07XHJcbm9udW5sb2FkKCkge1xyXG5cdGNvbnNvbGUubG9nKCd1bmxvYWRpbmcgcGx1Z2luJylcclxufVxyXG59Il0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFVQSxzQkFBdUI7QUFDdkIsSUFBTSxFQUFFLFNBQVMsUUFBUTtBQUV6QixJQUFJLFdBQVc7QUFDZixJQUFJLFdBQVc7QUFDZixJQUFNLFdBQVc7QUFFakIsSUFBTSxhQUFhLElBQUksUUFBUSxRQUFRLFlBQVksTUFBTSxTQUFTO0FBQ2xFLElBQU0sYUFBYSxJQUFJLFFBQVEsUUFBUSxZQUFZLE1BQU0sU0FBUztBQUNsRSxpQkFBaUI7QUFD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
